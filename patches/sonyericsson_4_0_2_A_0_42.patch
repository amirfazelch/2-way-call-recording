diff -urwd arch/arm/mach-msm/qdsp5v2.orig/audio_amrnb_in.c arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c
--- arch/arm/mach-msm/qdsp5v2.orig/audio_amrnb_in.c	2011-10-28 13:57:09.000000000 +0400
+++ arch/arm/mach-msm/qdsp5v2/audio_amrnb_in.c	2011-11-02 16:14:05.000000000 +0300
@@ -23,6 +23,8 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/dma-mapping.h>
+#include <linux/msm_audio.h>
+#include <linux/android_pmem.h>
 #include <linux/msm_audio_amrnb.h>
 
 #include <asm/atomic.h>
@@ -40,6 +42,16 @@
 #define FRAME_SIZE		(22 * 2) /* 36 bytes data */
 #define DMASZ 			(FRAME_SIZE * FRAME_NUM)
 
+#define AUDIO_GET_VOICE_STATE   _IOR(AUDIO_IOCTL_MAGIC, 55, unsigned)
+#define AUDIO_GET_DEV_DRV_VER   _IOR(AUDIO_IOCTL_MAGIC, 56, unsigned)
+#define DEV_DRV_VER             (8255 << 16 | 1)
+
+#define MM_AUD_ERR MM_ERR
+#define pr_aud_info pr_info
+
+
+extern int msm_get_voice_state(void);
+
 struct buffer {
 	void *data;
 	uint32_t size;
@@ -52,13 +64,18 @@
 
 	spinlock_t dsp_lock;
 
+	atomic_t opened;
 	atomic_t in_bytes;
 	atomic_t in_samples;
+	atomic_t rec_conf;
 
 	struct mutex lock;
 	struct mutex read_lock;
+
 	wait_queue_head_t wait;
 	wait_queue_head_t wait_enable;
+	wait_queue_head_t wait_voice_incall;
+	wait_queue_head_t wait_rec_cfg;
 
 	struct msm_adsp_module *audrec;
 
@@ -67,7 +84,6 @@
 	uint32_t enc_type;
 
 	int dtx_mode;
-	uint32_t frame_format;
 	uint32_t used_mode;
 	uint32_t rec_mode;
 
@@ -75,14 +91,11 @@
 	uint32_t in_head; /* next buffer dsp will write */
 	uint32_t in_tail; /* next buffer read() will read */
 	uint32_t in_count; /* number of buffers available to read() */
-	uint32_t mode;
 
-	const char *module_name;
 	unsigned queue_ids;
 	uint16_t enc_id;
 
 	uint16_t source; /* Encoding source bit mask */
-	uint32_t device_events;
 	uint32_t in_call;
 	uint32_t dev_cnt;
 	int voice_state;
@@ -92,12 +105,13 @@
 	char *data;
 	dma_addr_t phys;
 
-	int opened;
 	int enabled;
 	int running;
 	int stopped; /* set when stopped, cleared on flush */
 };
 
+struct audio_in the_audio_amrnb_in;
+
 struct audio_frame {
 	uint16_t frame_count_lsw;
 	uint16_t frame_count_msw;
@@ -108,14 +122,10 @@
 
 /* Audrec Queue command sent macro's */
 #define audrec_send_bitstreamqueue(audio, cmd, len) \
-	msm_adsp_write(audio->audrec, ((audio->queue_ids & 0xFFFF0000) >> 16),\
-			cmd, len)
+	msm_adsp_write(audio->audrec, ((audio->queue_ids & 0xFFFF0000) >> 16), cmd, len)
 
 #define audrec_send_audrecqueue(audio, cmd, len) \
-	msm_adsp_write(audio->audrec, (audio->queue_ids & 0x0000FFFF),\
-			cmd, len)
-
-struct audio_in the_audio_amrnb_in;
+	msm_adsp_write(audio->audrec, (audio->queue_ids & 0x0000FFFF), cmd, len)
 
 /* DSP command send functions */
 static int audamrnb_in_enc_config(struct audio_in *audio, int enable);
@@ -134,34 +144,33 @@
 	struct audio_in *audio = (struct audio_in *) private_data;
 	unsigned long flags;
 
-	MM_DBG("evt_id = 0x%8x\n", evt_id);
+	MM_DBG("evt_id = %d\n", evt_id);
 	switch (evt_id) {
 	case AUDDEV_EVT_DEV_RDY: {
 		MM_DBG("AUDDEV_EVT_DEV_RDY\n");
+
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt++;
-		if (!audio->in_call)
-			audio->source |= (0x1 << evt_payload->routing_id);
+		if (!audio->in_call) audio->source |= (0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if ((audio->running == 1) && (audio->enabled == 1))
 			audamrnb_in_record_config(audio, 1);
-
 		break;
 	}
 	case AUDDEV_EVT_DEV_RLS: {
 		MM_DBG("AUDDEV_EVT_DEV_RLS\n");
+
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt--;
-		if (!audio->in_call)
-			audio->source &= ~(0x1 << evt_payload->routing_id);
+		if (!audio->in_call) audio->source &= ~(0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if ((!audio->running) || (!audio->enabled))
 			break;
 
 		/* Turn of as per source */
-		if (audio->source)
+		if (audio->source && !audio->in_call)
 			audamrnb_in_record_config(audio, 1);
 		else
 			/* Turn off all */
@@ -173,7 +182,8 @@
 		MM_DBG("AUDDEV_EVT_VOICE_STATE_CHG, state = %d\n",
 				evt_payload->voice_state);
 		audio->voice_state = evt_payload->voice_state;
-		if (audio->in_call && audio->running) {
+                if (audio->in_call) {
+                        if(audio->running) {
 			if (audio->voice_state == VOICE_STATE_INCALL)
 				audamrnb_in_record_config(audio, 1);
 			else if (audio->voice_state == VOICE_STATE_OFFCALL) {
@@ -181,7 +191,8 @@
 				wake_up(&audio->wait);
 			}
 		}
-
+                        wake_up(&audio->wait_voice_incall);
+                }
 		break;
 	}
 	default:
@@ -191,7 +202,7 @@
 }
 
 /* ------------------- dsp preproc event handler--------------------- */
-static void audpreproc_dsp_event(void *data, unsigned id,  void *msg)
+static void amrnb_in_dsp_event(void *data, unsigned id,  void *msg)
 {
 	struct audio_in *audio = data;
 
@@ -212,12 +223,10 @@
 	case AUDPREPROC_CMD_ENC_CFG_DONE_MSG: {
 		struct audpreproc_cmd_enc_cfg_done_msg *enc_cfg_msg = msg;
 
-		MM_DBG("CMD_ENC_CFG_DONE_MSG: stream id %d enc type \
-			0x%8x\n", enc_cfg_msg->stream_id,
-			enc_cfg_msg->rec_enc_type);
+		MM_DBG("CMD_ENC_CFG_DONE_MSG: stream id %d enc type 0x%x\n", 
+			enc_cfg_msg->stream_id, enc_cfg_msg->rec_enc_type);
 		/* Encoder enable success */
-		if (enc_cfg_msg->rec_enc_type & ENCODE_ENABLE)
-			audamrnb_in_param_config(audio);
+		if (enc_cfg_msg->rec_enc_type & ENCODE_ENABLE) 	audamrnb_in_param_config(audio);
 		else { /* Encoder disable success */
 			audio->running = 0;
 			audamrnb_in_record_config(audio, 0);
@@ -231,9 +240,13 @@
 	}
 	case AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG: {
 		MM_DBG("AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG \n");
-		wake_up(&audio->wait_enable);
+		atomic_set(&audio->rec_conf,1);
+		wake_up(&audio->wait_rec_cfg);
 		break;
 	}
+        case ADSP_MESSAGE_ID:
+                pr_aud_info("audpre: enable/disable done\n");
+                break;
 	default:
 		MM_ERR("Unknown Event id %d\n", id);
 	}
@@ -247,12 +260,10 @@
 
 	switch (id) {
 	case AUDREC_CMD_MEM_CFG_DONE_MSG: {
-		MM_DBG("CMD_MEM_CFG_DONE MSG DONE\n");
+		MM_DBG("CMD_MEM_CFG_DONE\n");
 		audio->running = 1;
-		if ((!audio->in_call && (audio->dev_cnt > 0)) ||
-			(audio->in_call &&
-				(audio->voice_state == VOICE_STATE_INCALL)))
-			audamrnb_in_record_config(audio, 1);
+                if (!audio->in_call && (audio->dev_cnt > 0)) audamrnb_in_record_config(audio, 1);
+                wake_up(&audio->wait_enable);
 		break;
 	}
 	case AUDREC_FATAL_ERR_MSG: {
@@ -263,6 +274,7 @@
 				fatal_err_msg.audrec_err_id);
 		/* Error stop the encoder */
 		audio->stopped = 1;
+		wake_up(&audio->wait_voice_incall);
 		wake_up(&audio->wait);
 		break;
 	}
@@ -270,16 +282,18 @@
 		struct audrec_up_pkt_ready_msg pkt_ready_msg;
 
 		getevent(&pkt_ready_msg, AUDREC_UP_PACKET_READY_MSG_LEN);
-		MM_DBG("UP_PACKET_READY_MSG: write cnt lsw  %d \
-		write cnt msw %d read cnt lsw %d  read cnt msw %d \n",\
-		pkt_ready_msg.audrec_packet_write_cnt_lsw, \
-		pkt_ready_msg.audrec_packet_write_cnt_msw, \
-		pkt_ready_msg.audrec_up_prev_read_cnt_lsw, \
+		MM_DBG("UP_PACKET_READY_MSG: write lsw %d write msw %d read lsw %d read msw %d\n",
+		pkt_ready_msg.audrec_packet_write_cnt_lsw, 
+		pkt_ready_msg.audrec_packet_write_cnt_msw, 
+		pkt_ready_msg.audrec_up_prev_read_cnt_lsw, 
 		pkt_ready_msg.audrec_up_prev_read_cnt_msw);
 
 		audamrnb_in_get_dsp_frames(audio);
 		break;
 	}
+        case ADSP_MESSAGE_ID:
+                MM_DBG("audrec: enable/disable done\n");
+                break;
 	default:
 		MM_ERR("Unknown Event id %d\n", id);
 	}
@@ -316,6 +330,7 @@
 
 	wake_up(&audio->wait);
 }
+
 struct msm_adsp_ops audrec_amrnb_adsp_ops = {
 	.event = audrec_dsp_event,
 };
@@ -324,12 +339,13 @@
 {
 	struct audpreproc_audrec_cmd_enc_cfg cmd;
 
+	MM_DBG("enable=%d\n",enable);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.cmd_id = AUDPREPROC_AUDREC_CMD_ENC_CFG;
 	cmd.stream_id = audio->enc_id;
 
 	if (enable)
-		cmd.audrec_enc_type = audio->enc_type | ENCODE_ENABLE;
+		cmd.audrec_enc_type = ENC_TYPE_AMRNB | MSM_AUD_ENC_MODE_TUNNEL | ENCODE_ENABLE;
 	else
 		cmd.audrec_enc_type &= ~(ENCODE_ENABLE);
 
@@ -340,12 +356,11 @@
 {
 	struct audpreproc_audrec_cmd_parm_cfg_amrnb cmd;
 
+	MM_DBG("enc_id=%d, dtx=%d, used=%d\n",audio->enc_id, audio->dtx_mode, audio->used_mode);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.common.cmd_id = AUDPREPROC_AUDREC_CMD_PARAM_CFG;
 	cmd.common.stream_id = audio->enc_id;
-
 	cmd.dtx_mode = audio->dtx_mode;
-	cmd.test_mode = -1; /* Default set to -1 */
 	cmd.used_mode = audio->used_mode;
 
 	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
@@ -356,6 +371,7 @@
 {
 	struct audpreproc_afe_cmd_audio_record_cfg cmd;
 
+	MM_DBG("enable=%d\n",enable);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.cmd_id = AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG;
 	cmd.stream_id = audio->enc_id;
@@ -394,7 +410,8 @@
 	cmd.audrec_ext_pkt_start_addr_lsw = audio->phys;
 	cmd.audrec_ext_pkt_buf_number = FRAME_NUM;
 
-	/* prepare buffer pointers:
+	/* 
+	 * prepare buffer pointers:
 	 * 36 bytes amrnb packet + 4 halfword header
 	 */
 	for (n = 0; n < FRAME_NUM; n++) {
@@ -424,7 +441,7 @@
 	if (audio->enabled)
 		return 0;
 
-	if (audpreproc_enable(audio->enc_id, &audpreproc_dsp_event, audio)) {
+	if (audpreproc_enable(audio->enc_id, &amrnb_in_dsp_event, audio)) {
 		MM_ERR("msm_adsp_enable(audpreproc) failed\n");
 		return -ENODEV;
 	}
@@ -447,8 +464,8 @@
 		audio->enabled = 0;
 		audamrnb_in_enc_config(audio, 0);
 		wake_up(&audio->wait);
-		wait_event_interruptible_timeout(audio->wait_enable,
-				audio->running == 0, 1*HZ);
+		wake_up(&audio->wait_voice_incall);
+		wait_event_interruptible_timeout(audio->wait_enable, audio->running == 0, 1*HZ);
 		msm_adsp_disable(audio->audrec);
 		audpreproc_disable(audio->enc_id, audio);
 	}
@@ -463,6 +480,7 @@
 	audio->in_head = 0;
 	audio->in_tail = 0;
 	audio->in_count = 0;
+	audio->stopped = 0;
 	for (i = 0; i < FRAME_NUM; i++) {
 		audio->in[i].size = 0;
 		audio->in[i].read = 0;
@@ -480,61 +498,105 @@
 	struct audio_in *audio = file->private_data;
 	int rc = 0;
 
-	if (cmd == AUDIO_GET_STATS) {
+        if (cmd == AUDIO_STOP) {
+                audio->stopped = 1;
+                wake_up(&audio->wait_voice_incall);
+        }
+
+	mutex_lock(&audio->lock);
+
+	switch (cmd) {
+
+        case AUDIO_GET_STATS: {
 		struct msm_audio_stats stats;
 		stats.byte_count = atomic_read(&audio->in_bytes);
 		stats.sample_count = atomic_read(&audio->in_samples);
 		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return rc;
+                        rc = -EFAULT;
+                break;
+        }
+        case AUDIO_GET_VOICE_STATE: {
+                int vstate = audio->voice_state;
+                if (copy_to_user((void *) arg, &vstate, sizeof(vstate)))
+                        rc = -EFAULT;
+                break;
+        }
+        case AUDIO_GET_DEV_DRV_VER: {
+                unsigned int vers = DEV_DRV_VER;
+                if (copy_to_user((void *) arg, &vers, sizeof(vers)))
+                        rc = -EFAULT;
+                break;
 	}
-
-	mutex_lock(&audio->lock);
-	switch (cmd) {
 	case AUDIO_START: {
+
 		uint32_t freq;
+                struct timespec ts;
+                /* Poll at 48KHz always */
 		freq = 48000;
 		MM_DBG("AUDIO_START\n");
-		if (audio->in_call && (audio->voice_state !=
-				VOICE_STATE_INCALL)) {
-			rc = -EPERM;
-			break;
+
+                if (audio->in_call && (audio->voice_state != VOICE_STATE_INCALL)) {
+                        ts = CURRENT_TIME;
+                        rc = wait_event_interruptible(audio->wait_voice_incall,
+                                audio->voice_state == VOICE_STATE_INCALL || audio->stopped);
+                        if(rc < 0 || audio->voice_state != VOICE_STATE_INCALL || audio->stopped) {
+                                MM_DBG("valid incall state unreacheable\n");
+                                return -EPERM;
 		}
-		rc = msm_snddev_request_freq(&freq, audio->enc_id,
-					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
-		MM_DBG("sample rate configured %d\n", freq);
+                        ts = timespec_sub(CURRENT_TIME,ts);
+                        MM_DBG("waited %ld.%ldms for voice incall state\n", ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+                }
+
+                rc = msm_snddev_request_freq(&freq, audio->enc_id,SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 		if (rc < 0) {
-			MM_DBG(" Sample rate can not be set, return code %d\n",
-								 rc);
+                        MM_DBG("sample rate can not be set, return code %d\n",rc);
 			msm_snddev_withdraw_freq(audio->enc_id,
 					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 			MM_DBG("msm_snddev_withdraw_freq\n");
 			break;
 		}
+                MM_DBG("sample rate configured %d\n", freq);
+
 		rc = audamrnb_in_enable(audio);
-		if (!rc) {
-			rc =
-			wait_event_interruptible_timeout(audio->wait_enable,
-				audio->running != 0, 1*HZ);
-			MM_DBG("state %d rc = %d\n", audio->running, rc);
+                if (rc == 0) {
+                        ts = CURRENT_TIME;
+                        rc = wait_event_interruptible_timeout(audio->wait_enable, audio->running != 0, 3*HZ);
+                        ts = timespec_sub(CURRENT_TIME,ts);
+                        MM_DBG("state = %d, rc = %d after %ld.%03ld sec\n", audio->running, rc,
+                                                        ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+                        rc = (audio->running == 0) ? -ENODEV : 0;
+                } else MM_DBG("failed to enable audpcm\n");
 
-			if (audio->running == 0)
-				rc = -ENODEV;
-			else
-				rc = 0;
+                if (rc == 0 && audio->in_call) {
+                        rc = audamrnb_in_record_config(audio, 1);
+                        if (rc != 0) MM_ERR("failed to send record config cmd\n");
+                        else  {
+                                ts = CURRENT_TIME;
+                                atomic_set(&audio->rec_conf,0);
+                                wait_event_interruptible_timeout(audio->wait_rec_cfg,
+                                        atomic_read(&audio->rec_conf) != 0, 3*HZ);
+                                if (atomic_read(&audio->rec_conf) == 0) {
+                                        MM_DBG("failed to config recording\n");
+                                        rc = -EFAULT;
+                                } else {
+                                        ts = timespec_sub(CURRENT_TIME,ts);
+                                        MM_DBG("record config success after %ld.%03ld sec\n",
+                                                        ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+                                }
+                        }
 		}
 		audio->stopped = 0;
 		break;
 	}
 	case AUDIO_STOP: {
+		MM_DBG("AUDIO_STOP\n");
 		rc = audamrnb_in_disable(audio);
-		rc = msm_snddev_withdraw_freq(audio->enc_id,
-					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
-		MM_DBG("msm_snddev_withdraw_freq\n");
-		audio->stopped = 1;
+		if (rc != 0) MM_DBG("failed to stop audio\n");
+		rc = msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 		break;
 	}
 	case AUDIO_FLUSH: {
+		MM_DBG("AUDIO_FLUSH\n");
 		if (audio->stopped) {
 			/* Make sure we're stopped and we wake any threads
 			 * that might be blocked holding the read_lock.
@@ -549,16 +611,6 @@
 		break;
 	}
 	case AUDIO_SET_STREAM_CONFIG: {
-		struct msm_audio_stream_config cfg;
-		if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
-			rc = -EFAULT;
-			break;
-		}
-		/* Allow only single frame */
-		if (cfg.buffer_size != (FRAME_SIZE - 8))
-			rc = -EINVAL;
-		else
-			audio->buffer_size = cfg.buffer_size;
 		break;
 	}
 	case AUDIO_GET_STREAM_CONFIG: {
@@ -573,9 +625,8 @@
 	case AUDIO_GET_AMRNB_ENC_CONFIG_V2: {
 		struct msm_audio_amrnb_enc_config_v2 cfg;
 		memset(&cfg, 0, sizeof(cfg));
-		cfg.dtx_enable = ((audio->dtx_mode == -1) ? 1 : 0);
+		cfg.dtx_enable = ((audio->dtx_mode == AMRNB_DTX_MODE_ENABLE) ? 1 : 0);
 		cfg.band_mode = audio->used_mode;
-		cfg.frame_format = audio->frame_format;
 		if (copy_to_user((void *) arg, &cfg, sizeof(cfg)))
 			rc = -EFAULT;
 		break;
@@ -586,25 +637,14 @@
 			rc = -EFAULT;
 			break;
 		}
-		/* DSP does not support any other than default format */
-		if (audio->frame_format != cfg.frame_format) {
-			rc = -EINVAL;
-			break;
-		}
-		if (cfg.dtx_enable == 0)
-			audio->dtx_mode = 0;
-		else if (cfg.dtx_enable == 1)
-			audio->dtx_mode = -1;
-		else {
-			rc = -EINVAL;
-			break;
-		}
+		audio->dtx_mode = cfg.dtx_enable ? AMRNB_DTX_MODE_ENABLE : AMRNB_DTX_MODE_DISABLE;
 		audio->used_mode = cfg.band_mode;
 		break;
 	}
 	case AUDIO_SET_INCALL: {
 		struct msm_voicerec_mode cfg;
 		unsigned long flags;
+		MM_DBG("AUDIO_SET_INCALL\n");
 		if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
 			rc = -EFAULT;
 			break;
@@ -639,10 +679,41 @@
 	default:
 		rc = -EINVAL;
 	}
+	if(rc != 0) MM_DBG("returning error %d\n",rc);
 	mutex_unlock(&audio->lock);
 	return rc;
 }
 
+static int reconfig_record(struct audio_in *audio) {
+
+	MM_DBG("\n");
+	mutex_lock(&audio->lock);
+	atomic_set(&audio->rec_conf,0);
+	if (audamrnb_in_record_config(audio, 0) != 0) {
+		mutex_unlock(&audio->lock);
+		return -EFAULT;
+	}
+	wait_event_interruptible_timeout(audio->wait_rec_cfg,
+			atomic_read(&audio->rec_conf) == 1, 1*HZ);
+	if (atomic_read(&audio->rec_conf) != 1) {
+		mutex_unlock(&audio->lock);
+		return -ENODEV;
+	}
+	atomic_set(&audio->rec_conf,0);
+	if (audamrnb_in_record_config(audio, 1) != 0) {
+		mutex_unlock(&audio->lock);
+		return -EFAULT;
+	}
+	wait_event_interruptible_timeout(audio->wait_rec_cfg,
+			atomic_read(&audio->rec_conf) == 1, 1*HZ);
+	if (atomic_read(&audio->rec_conf) != 1) {
+		mutex_unlock(&audio->lock);
+		return -ENODEV;
+	}
+	mutex_unlock(&audio->lock);
+	return 0;
+}
+
 static ssize_t audamrnb_in_read(struct file *file,
 				char __user *buf,
 				size_t count, loff_t *pos)
@@ -657,15 +728,26 @@
 
 	mutex_lock(&audio->read_lock);
 	while (count > 0) {
-		rc = wait_event_interruptible(
-			audio->wait, (audio->in_count > 0) || audio->stopped
-			|| (audio->in_call && audio->running &&
-				(audio->voice_state == VOICE_STATE_OFFCALL)));
-		if (rc < 0)
+
+		rc = wait_event_interruptible_timeout(
+			audio->wait, (audio->in_count > 0) || audio->stopped ||
+			(audio->in_call && audio->running &&
+				(audio->voice_state == VOICE_STATE_OFFCALL)), 3*HZ);
+
+		if (rc == 0 && !audio->in_count 
+			&& !audio->stopped && audio->voice_state == VOICE_STATE_INCALL) {
+                        rc = reconfig_record(audio);
+                        if (rc == 0) {
+                                MM_DBG("Recording reconfigured\n");
+                                continue;
+                        }
+                        MM_AUD_ERR("Failed to reconfigure recording\n");
 			break;
+		} else rc = 0;
 
 		if (!audio->in_count) {
 			if (audio->stopped)  {
+				MM_AUD_ERR("Driver stopped, no more to read");
 				rc = 0;/* End of File */
 				break;
 			} else if (audio->in_call && audio->running &&
@@ -686,8 +768,7 @@
 			}
 			spin_lock_irqsave(&audio->dsp_lock, flags);
 			if (index != audio->in_tail) {
-				/* overrun -- data is
-				 * invalid and we need to retry */
+				/* overrun -- data are invalid and we need to retry */
 				spin_unlock_irqrestore(&audio->dsp_lock, flags);
 				continue;
 			}
@@ -698,7 +779,7 @@
 			count -= size;
 			buf += size;
 		} else {
-			MM_ERR("short read\n");
+			MM_ERR("short read: count=%d, size=%d, buf-start=%d\n", count, size, buf-start);
 			break;
 		}
 	}
@@ -721,99 +802,108 @@
 {
 	struct audio_in *audio = file->private_data;
 
-	MM_DBG("\n");
 	mutex_lock(&audio->lock);
 	audio->in_call = 0;
-	/* with draw frequency for session
-	   incase not stopped the driver */
-	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX,
-					AUDDEV_CLNT_ENC);
+
+	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 	auddev_unregister_evt_listner(AUDDEV_CLNT_ENC, audio->enc_id);
 	audamrnb_in_disable(audio);
 	audamrnb_in_flush(audio);
 	msm_adsp_put(audio->audrec);
 	audpreproc_aenc_free(audio->enc_id);
-	audio->audrec = NULL;
-	audio->opened = 0;
+	atomic_set(&audio->opened,0);
+
 	mutex_unlock(&audio->lock);
+
+	MM_DBG("closed.\n");
+
 	return 0;
 }
 
 static int audamrnb_in_open(struct inode *inode, struct file *file)
 {
 	struct audio_in *audio = &the_audio_amrnb_in;
+	const char *modname;
 	int rc;
-	int encid;
 
 	mutex_lock(&audio->lock);
-	if (audio->opened) {
-		rc = -EBUSY;
-		goto done;
+
+        if (atomic_read(&audio->opened) != 0) {
+                MM_AUD_ERR("Already open\n");
+                mutex_unlock(&audio->lock);
+                return -EBUSY;
+        }
+
+        if (!audio->phys) {
+                audio->phys = pmem_kalloc(DMASZ, PMEM_MEMTYPE_EBI1 | PMEM_ALIGNMENT_4K);
+                if (!IS_ERR((void *) audio->phys)) {
+                        audio->data = ioremap(audio->phys, DMASZ);
+                        if (!audio->data) {
+                                MM_AUD_ERR("Could not remap DMA buffers\n");
+                                pmem_kfree(audio->phys);
+                                audio->phys = 0;
+                                mutex_unlock(&audio->lock);
+                                return -ENOMEM;
 	}
-	if ((file->f_mode & FMODE_WRITE) &&
-			(file->f_mode & FMODE_READ)) {
-		rc = -EACCES;
-		MM_ERR("Non tunnel encoding is not supported\n");
-		goto done;
-	} else if (!(file->f_mode & FMODE_WRITE) &&
-					(file->f_mode & FMODE_READ)) {
-		audio->mode = MSM_AUD_ENC_MODE_TUNNEL;
-		MM_DBG("Opened for tunnel mode encoding\n");
 	} else {
-		rc = -EACCES;
-		goto done;
+                        MM_AUD_ERR("Could not allocate DMA buffers\n");
+                        audio->phys = 0;
+                        mutex_unlock(&audio->lock);
+                        return -ENOMEM;
+                }
 	}
 
-
-	/* Settings will be re-config at AUDIO_SET_CONFIG,
-	 * but at least we need to have initial config
-	 */
-	audio->buffer_size = (FRAME_SIZE - 8);
-	audio->enc_type = ENC_TYPE_AMRNB | audio->mode;
-	audio->dtx_mode = -1;
-	audio->frame_format = 0;
-	audio->used_mode = 7; /* Bit Rate 12.2 kbps MR122 */
-
-	encid = audpreproc_aenc_alloc(audio->enc_type, &audio->module_name,
-			&audio->queue_ids);
-	if (encid < 0) {
+	audio->enc_id = audpreproc_aenc_alloc(ENC_TYPE_AMRNB | MSM_AUD_ENC_MODE_TUNNEL, 
+					&modname, &audio->queue_ids);
+	if (audio->enc_id < 0) {
 		MM_ERR("No free encoder available\n");
-		rc = -ENODEV;
-		goto done;
+                mutex_unlock(&audio->lock);
+                return -ENODEV;
 	}
-	audio->enc_id = encid;
 
-	rc = msm_adsp_get(audio->module_name, &audio->audrec,
-			   &audrec_amrnb_adsp_ops, audio);
+        MM_DBG("allocated encoder %d, module %s\n", audio->enc_id, modname);
 
+	rc = auddev_register_evt_listner(AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
+					AUDDEV_EVT_VOICE_STATE_CHG,
+					AUDDEV_CLNT_ENC, audio->enc_id,
+					amrnb_in_listener, (void *) audio);
 	if (rc) {
-		audpreproc_aenc_free(audio->enc_id);
-		goto done;
+		MM_ERR("failed to register device event listener\n");
+		goto evt_error;
 	}
 
-	audio->stopped = 0;
-	audio->source = 0;
+        rc = msm_adsp_get(modname, &audio->audrec, &audrec_amrnb_adsp_ops, audio);
 
-	audamrnb_in_flush(audio);
+        if (rc) {
+                MM_AUD_ERR("Failed to get AUDREC task\n");
+                goto no_audrec;
+        }
 
-	audio->device_events = AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
-				AUDDEV_EVT_VOICE_STATE_CHG;
+        if(!audio->audrec) {
+                MM_AUD_ERR("Null AUDREC task returned by ADSP\n");
+                goto no_audrec;
+        }
 
+	audio->source = INTERNAL_CODEC_TX_SOURCE_MIX_MASK;
+	audio->buffer_size = (FRAME_SIZE - 8);
+	audio->enc_type = ENC_TYPE_AMRNB | MSM_AUD_ENC_MODE_TUNNEL;
+	audio->dtx_mode = AMRNB_DTX_MODE_ENABLE;
+	audio->used_mode = AMRNB_USED_MODE_MR122; /* Bit Rate 12.2 kbps */
+	audio->stopped = 0;
+	audio->running = 0;
+	audio->enabled = 0;
+	audamrnb_in_flush(audio);
 	audio->voice_state = msm_get_voice_state();
-	rc = auddev_register_evt_listner(audio->device_events,
-					AUDDEV_CLNT_ENC, audio->enc_id,
-					amrnb_in_listener, (void *) audio);
-	if (rc) {
-		MM_ERR("failed to register device event listener\n");
-		goto evt_error;
-	}
 	file->private_data = audio;
-	audio->opened = 1;
-done:
+	atomic_set(&audio->opened,1);
+
 	mutex_unlock(&audio->lock);
+
 	return rc;
+
+no_audrec:
+        auddev_unregister_evt_listner(AUDDEV_CLNT_ENC, audio->enc_id);
 evt_error:
-	msm_adsp_put(audio->audrec);
 	audpreproc_aenc_free(audio->enc_id);
 	mutex_unlock(&audio->lock);
 	return rc;
@@ -836,22 +926,19 @@
 
 static int __init audamrnb_in_init(void)
 {
-	the_audio_amrnb_in.data = dma_alloc_coherent(NULL, DMASZ,
-				       &the_audio_amrnb_in.phys, GFP_KERNEL);
-	MM_DBG("Memory addr = 0x%8x  Phy addr= 0x%8x ---- \n", \
-		(int) the_audio_amrnb_in.data, (int) the_audio_amrnb_in.phys);
-
-	if (!the_audio_amrnb_in.data) {
-		MM_ERR("Unable to allocate DMA buffer\n");
-		return -ENOMEM;
-	}
+	the_audio_amrnb_in.phys = 0;
+	atomic_set(&the_audio_amrnb_in.opened,0);
 	mutex_init(&the_audio_amrnb_in.lock);
 	mutex_init(&the_audio_amrnb_in.read_lock);
 	spin_lock_init(&the_audio_amrnb_in.dsp_lock);
 	spin_lock_init(&the_audio_amrnb_in.dev_lock);
 	init_waitqueue_head(&the_audio_amrnb_in.wait);
 	init_waitqueue_head(&the_audio_amrnb_in.wait_enable);
+	init_waitqueue_head(&the_audio_amrnb_in.wait_voice_incall);
+	init_waitqueue_head(&the_audio_amrnb_in.wait_rec_cfg);
+
 	return misc_register(&audio_amrnb_in_misc);
 }
 
 device_initcall(audamrnb_in_init);
+
diff -urwd arch/arm/mach-msm/qdsp5v2.orig/audio_pcm_in.c arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c
--- arch/arm/mach-msm/qdsp5v2.orig/audio_pcm_in.c	2011-10-28 13:57:09.000000000 +0400
+++ arch/arm/mach-msm/qdsp5v2/audio_pcm_in.c	2011-11-02 15:32:48.000000000 +0300
@@ -24,6 +24,11 @@
 #include <linux/wait.h>
 #include <linux/dma-mapping.h>
 #include <linux/msm_audio.h>
+//#include <linux/msm_audio_7X30.h>
+#include <linux/android_pmem.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
 
 #include <asm/atomic.h>
 #include <asm/ioctls.h>
@@ -33,6 +38,7 @@
 #include <mach/qdsp5v2/qdsp5audrecmsg.h>
 #include <mach/qdsp5v2/audpreproc.h>
 #include <mach/qdsp5v2/audio_dev_ctl.h>
+#include <mach/qdsp5v2/afe.h>
 #include <mach/debug_mm.h>
 
 /* FRAME_NUM must be a power of two */
@@ -42,6 +48,15 @@
 #define STEREO_DATA_SIZE	(MONO_DATA_SIZE * 2)
 #define DMASZ 			(FRAME_SIZE * FRAME_NUM)
 
+#define AUDIO_GET_VOICE_STATE   _IOR(AUDIO_IOCTL_MAGIC, 55, unsigned)
+#define AUDIO_GET_DEV_DRV_VER   _IOR(AUDIO_IOCTL_MAGIC, 56, unsigned)
+#define DEV_DRV_VER             (8255 << 16 | 1)
+
+#define MM_AUD_ERR MM_ERR
+#define pr_aud_info pr_info
+
+extern int msm_get_voice_state(void);
+	
 struct buffer {
 	void *data;
 	uint32_t size;
@@ -56,11 +71,15 @@
 
 	atomic_t in_bytes;
 	atomic_t in_samples;
+	atomic_t rec_conf;
 
 	struct mutex lock;
 	struct mutex read_lock;
+
 	wait_queue_head_t wait;
 	wait_queue_head_t wait_enable;
+	wait_queue_head_t wait_voice_incall;
+	wait_queue_head_t wait_rec_cfg;
 
 	struct msm_adsp_module *audrec;
 
@@ -68,35 +87,34 @@
 	uint32_t samp_rate;
 	uint32_t channel_mode;
 	uint32_t buffer_size; /* 2048 for mono, 4096 for stereo */
-	uint32_t enc_type;
 
 	uint32_t dsp_cnt;
 	uint32_t in_head; /* next buffer dsp will write */
 	uint32_t in_tail; /* next buffer read() will read */
 	uint32_t in_count; /* number of buffers available to read() */
-	uint32_t mode;
 
-	const char *module_name;
 	unsigned queue_ids;
 	uint16_t enc_id; /* Session Id */
 
 	uint16_t source; /* Encoding source bit mask */
-	uint32_t device_events; /* device events interested in */
+        uint32_t in_call;
 	uint32_t dev_cnt;
+        int voice_state;
 	spinlock_t dev_lock;
 
 	/* data allocated for various buffers */
 	char *data;
 	dma_addr_t phys;
 
-	int opened;
 	int enabled;
 	int running;
 	int stopped; /* set when stopped, cleared on flush */
-	int abort; /* set when error, like sample rate mismatch */
 };
 
-static struct audio_in the_audio_in;
+#ifdef TEST_ONLY
+struct audio_in *current_audio_in;
+EXPORT_SYMBOL(current_audio_in);
+#endif
 
 struct audio_frame {
 	uint16_t frame_count_lsw;
@@ -108,12 +126,10 @@
 
 /* Audrec Queue command sent macro's */
 #define audrec_send_bitstreamqueue(audio, cmd, len) \
-	msm_adsp_write(audio->audrec, ((audio->queue_ids & 0xFFFF0000) >> 16),\
-			cmd, len)
+	msm_adsp_write(audio->audrec, ((audio->queue_ids & 0xFFFF0000) >> 16), cmd, len)
 
 #define audrec_send_audrecqueue(audio, cmd, len) \
-	msm_adsp_write(audio->audrec, (audio->queue_ids & 0x0000FFFF),\
-			cmd, len)
+	msm_adsp_write(audio->audrec, (audio->queue_ids & 0x0000FFFF), cmd, len)
 
 /* DSP command send functions */
 static int audpcm_in_enc_config(struct audio_in *audio, int enable);
@@ -126,38 +142,39 @@
 
 static void audpcm_in_flush(struct audio_in *audio);
 
-static void pcm_in_listener(u32 evt_id, union auddev_evt_data *evt_payload,
+static void audpcm_in_listener(u32 evt_id, union auddev_evt_data *evt_payload,
 				void *private_data)
 {
 	struct audio_in *audio = (struct audio_in *) private_data;
 	unsigned long flags;
 
-	MM_DBG("evt_id = 0x%8x\n", evt_id);
+	MM_DBG("evt_id = %d\n", evt_id);
 	switch (evt_id) {
 	case AUDDEV_EVT_DEV_RDY: {
 		MM_DBG("AUDDEV_EVT_DEV_RDY\n");
+
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt++;
-		audio->source |= (0x1 << evt_payload->routing_id);
+		if (!audio->in_call) audio->source |= (0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if ((audio->running == 1) && (audio->enabled == 1))
 			audpcm_in_record_config(audio, 1);
-
 		break;
 	}
 	case AUDDEV_EVT_DEV_RLS: {
 		MM_DBG("AUDDEV_EVT_DEV_RLS\n");
+
 		spin_lock_irqsave(&audio->dev_lock, flags);
 		audio->dev_cnt--;
-		audio->source &= ~(0x1 << evt_payload->routing_id);
+		if (!audio->in_call) audio->source &= ~(0x1 << evt_payload->routing_id);
 		spin_unlock_irqrestore(&audio->dev_lock, flags);
 
 		if (!audio->running || !audio->enabled)
 			break;
 
-		/* Turn of as per source */
-		if (audio->source)
+		/* Turn off as per source */
+		if (audio->source && !audio->in_call)
 			audpcm_in_record_config(audio, 1);
 		else
 			/* Turn off all */
@@ -165,8 +182,25 @@
 
 		break;
 	}
+        case AUDDEV_EVT_VOICE_STATE_CHG: {
+                MM_DBG("AUDDEV_EVT_VOICE_STATE_CHG, state = %d\n",
+                                evt_payload->voice_state);
+                audio->voice_state = evt_payload->voice_state;
+                if (audio->in_call) {
+			if(audio->running) {
+	                        if (audio->voice_state == VOICE_STATE_INCALL)
+        	                        audpcm_in_record_config(audio, 1);
+	                        else if (audio->voice_state == VOICE_STATE_OFFCALL) {
+	                                audpcm_in_record_config(audio, 0);
+	                                wake_up(&audio->wait);
+	                        }
+			}
+			wake_up(&audio->wait_voice_incall);
+                }
+                break;
+        }
 	case AUDDEV_EVT_FREQ_CHG: {
-		MM_DBG("Encoder Driver got sample rate change event\n");
+		MM_DBG("Encoder driver: got sample rate change event\n");
 		MM_DBG("sample rate %d\n", evt_payload->freq_info.sample_rate);
 		MM_DBG("dev_type %d\n", evt_payload->freq_info.dev_type);
 		MM_DBG("acdb_dev_id %d\n", evt_payload->freq_info.acdb_dev_id);
@@ -176,20 +210,21 @@
 			if (evt_payload->freq_info.sample_rate !=
 				audio->samp_rate) {
 				audpcm_in_record_config(audio, 0);
-				audio->abort = 1;
+				audio->stopped = 1;
 				wake_up(&audio->wait);
+				wake_up(&audio->wait_voice_incall);
 			}
 		}
 		break;
 	}
 	default:
-		MM_ERR("wrong event %d\n", evt_id);
+		MM_AUD_ERR("wrong event %d\n", evt_id);
 		break;
 	}
 }
 
 /* ------------------- dsp preproc event handler--------------------- */
-static void audpreproc_dsp_event(void *data, unsigned id,  void *msg)
+static void audpcm_in_dsp_event(void *data, unsigned id,  void *msg)
 {
 	struct audio_in *audio = data;
 
@@ -210,12 +245,10 @@
 	case AUDPREPROC_CMD_ENC_CFG_DONE_MSG: {
 		struct audpreproc_cmd_enc_cfg_done_msg *enc_cfg_msg = msg;
 
-		MM_DBG("CMD_ENC_CFG_DONE_MSG: stream id %d enc type \
-			0x%8x\n", enc_cfg_msg->stream_id,
-			enc_cfg_msg->rec_enc_type);
+		MM_DBG("CMD_ENC_CFG_DONE_MSG: stream id %d enc type 0x%x\n", 
+			enc_cfg_msg->stream_id,	enc_cfg_msg->rec_enc_type);
 		/* Encoder enable success */
-		if (enc_cfg_msg->rec_enc_type & ENCODE_ENABLE)
-			audpcm_in_param_config(audio);
+		if (enc_cfg_msg->rec_enc_type & ENCODE_ENABLE) 	audpcm_in_param_config(audio);
 		else { /* Encoder disable success */
 			audio->running = 0;
 			audpcm_in_record_config(audio, 0);
@@ -228,12 +261,16 @@
 		break;
 	}
 	case AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG: {
-		MM_DBG("AFE_CMD_AUDIO_RECORD_CFG_DONE_MSG \n");
-		wake_up(&audio->wait_enable);
+		MM_DBG("CMD_RECORD_CFG_DONE_MSG \n");
+		atomic_set(&audio->rec_conf,1);
+		wake_up(&audio->wait_rec_cfg);
 		break;
 	}
+	case ADSP_MESSAGE_ID:
+		pr_aud_info("audpre: enable/disable done\n");
+		break;
 	default:
-		MM_ERR("Unknown Event id %d\n", id);
+		MM_AUD_ERR("Unknown Event id %d\n", id);
 	}
 }
 
@@ -245,20 +282,21 @@
 
 	switch (id) {
 	case AUDREC_CMD_MEM_CFG_DONE_MSG: {
-		MM_DBG("CMD_MEM_CFG_DONE MSG DONE\n");
+		MM_DBG("CMD_MEM_CFG_DONE\n");
 		audio->running = 1;
-		if (audio->dev_cnt > 0)
-			audpcm_in_record_config(audio, 1);
+		if (!audio->in_call && (audio->dev_cnt > 0)) audpcm_in_record_config(audio, 1);
+		wake_up(&audio->wait_enable);
 		break;
 	}
 	case AUDREC_FATAL_ERR_MSG: {
 		struct audrec_fatal_err_msg fatal_err_msg;
 
 		getevent(&fatal_err_msg, AUDREC_FATAL_ERR_MSG_LEN);
-		MM_ERR("FATAL_ERR_MSG: err id %d\n",
+		MM_AUD_ERR("FATAL_ERR_MSG: err id %d\n",
 				fatal_err_msg.audrec_err_id);
 		/* Error stop the encoder */
 		audio->stopped = 1;
+		wake_up(&audio->wait_voice_incall);
 		wake_up(&audio->wait);
 		break;
 	}
@@ -266,18 +304,20 @@
 		struct audrec_up_pkt_ready_msg pkt_ready_msg;
 
 		getevent(&pkt_ready_msg, AUDREC_UP_PACKET_READY_MSG_LEN);
-		MM_DBG("UP_PACKET_READY_MSG: write cnt lsw  %d \
-		write cnt msw %d read cnt lsw %d  read cnt msw %d \n",\
-		pkt_ready_msg.audrec_packet_write_cnt_lsw, \
-		pkt_ready_msg.audrec_packet_write_cnt_msw, \
-		pkt_ready_msg.audrec_up_prev_read_cnt_lsw, \
+		MM_DBG("UP_PACKET_READY_MSG: write lsw %d write msw %d read lsw %d read msw %d\n",
+		pkt_ready_msg.audrec_packet_write_cnt_lsw,
+		pkt_ready_msg.audrec_packet_write_cnt_msw,
+		pkt_ready_msg.audrec_up_prev_read_cnt_lsw,
 		pkt_ready_msg.audrec_up_prev_read_cnt_msw);
 
 		audpcm_in_get_dsp_frames(audio);
 		break;
 	}
+	case ADSP_MESSAGE_ID:
+		MM_DBG("audrec: enable/disable done\n");
+		break;
 	default:
-		MM_ERR("Unknown Event id %d\n", id);
+		MM_AUD_ERR("Unknown Event id %d\n", id);
 	}
 }
 
@@ -307,7 +347,9 @@
 	else
 		audio->in_count++;
 
-	audpcm_dsp_read_buffer(audio, audio->dsp_cnt++);
+	if (!audio->stopped) audpcm_dsp_read_buffer(audio, audio->dsp_cnt++);
+	else audio->in_count = 0;
+
 	spin_unlock_irqrestore(&audio->dsp_lock, flags);
 
 	wake_up(&audio->wait);
@@ -321,12 +363,13 @@
 {
 	struct audpreproc_audrec_cmd_enc_cfg cmd;
 
+	MM_DBG("enable=%d\n",enable);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.cmd_id = AUDPREPROC_AUDREC_CMD_ENC_CFG;
 	cmd.stream_id = audio->enc_id;
 
 	if (enable)
-		cmd.audrec_enc_type = audio->enc_type | ENCODE_ENABLE;
+		cmd.audrec_enc_type = ENC_TYPE_WAV | MSM_AUD_ENC_MODE_TUNNEL | ENCODE_ENABLE;
 	else
 		cmd.audrec_enc_type &= ~(ENCODE_ENABLE);
 
@@ -337,21 +380,23 @@
 {
 	struct audpreproc_audrec_cmd_parm_cfg_wav cmd;
 
+	MM_DBG("enc_id=%d, rate=%d, chan_mode=%d\n",audio->enc_id, audio->samp_rate, audio->channel_mode);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.common.cmd_id = AUDPREPROC_AUDREC_CMD_PARAM_CFG;
 	cmd.common.stream_id = audio->enc_id;
-
 	cmd.aud_rec_samplerate_idx = audio->samp_rate;
 	cmd.aud_rec_stereo_mode = audio->channel_mode;
 
 	return audpreproc_send_audreccmdqueue(&cmd, sizeof(cmd));
 }
 
+
 /* To Do: msm_snddev_route_enc(audio->enc_id); */
 static int audpcm_in_record_config(struct audio_in *audio, int enable)
 {
 	struct audpreproc_afe_cmd_audio_record_cfg cmd;
 
+	MM_DBG("enable=%d\n",enable);
 	memset(&cmd, 0, sizeof(cmd));
 	cmd.cmd_id = AUDPREPROC_AFE_CMD_AUDIO_RECORD_CFG;
 	cmd.stream_id = audio->enc_id;
@@ -421,13 +466,13 @@
 	if (audio->enabled)
 		return 0;
 
-	if (audpreproc_enable(audio->enc_id, &audpreproc_dsp_event, audio)) {
-		MM_ERR("msm_adsp_enable(audpreproc) failed\n");
+	if (audpreproc_enable(audio->enc_id, &audpcm_in_dsp_event, audio)) {
+		MM_AUD_ERR("msm_adsp_enable(audpreproc) failed\n");
 		return -ENODEV;
 	}
 
 	if (msm_adsp_enable(audio->audrec)) {
-		MM_ERR("msm_adsp_enable(audrec) failed\n");
+		MM_AUD_ERR("msm_adsp_enable(audrec) failed\n");
 		audpreproc_disable(audio->enc_id, audio);
 		return -ENODEV;
 	}
@@ -444,8 +489,8 @@
 		audio->enabled = 0;
 		audpcm_in_enc_config(audio, 0);
 		wake_up(&audio->wait);
-		wait_event_interruptible_timeout(audio->wait_enable,
-				audio->running == 0, 1*HZ);
+		wake_up(&audio->wait_voice_incall);
+		wait_event_interruptible_timeout(audio->wait_enable, audio->running == 0, 1*HZ);
 		msm_adsp_disable(audio->audrec);
 		audpreproc_disable(audio->enc_id, audio);
 	}
@@ -460,6 +505,7 @@
 	audio->in_head = 0;
 	audio->in_tail = 0;
 	audio->in_count = 0;
+	audio->stopped = 0;
 	for (i = 0; i < FRAME_NUM; i++) {
 		audio->in[i].size = 0;
 		audio->in[i].read = 0;
@@ -477,59 +523,108 @@
 	struct audio_in *audio = file->private_data;
 	int rc = 0;
 
-	if (cmd == AUDIO_GET_STATS) {
+	if (cmd == AUDIO_STOP) {
+		unsigned long flags;
+		MM_DBG("AUDIO_STOP\n");
+		spin_lock_irqsave(&audio->dsp_lock, flags);
+		audio->stopped = 1;
+		spin_unlock_irqrestore(&audio->dsp_lock, flags);
+		wake_up(&audio->wait_voice_incall);
+	}
+
+	mutex_lock(&audio->lock);
+
+	switch (cmd) {
+
+	case AUDIO_GET_STATS: {
 		struct msm_audio_stats stats;
 		stats.byte_count = atomic_read(&audio->in_bytes);
 		stats.sample_count = atomic_read(&audio->in_samples);
 		if (copy_to_user((void *) arg, &stats, sizeof(stats)))
-			return -EFAULT;
-		return rc;
+			rc = -EFAULT;
+		break;
+        }
+	case AUDIO_GET_VOICE_STATE: {
+		int vstate = audio->voice_state;
+		if (copy_to_user((void *) arg, &vstate, sizeof(vstate)))
+			rc = -EFAULT;
+		break;
+        }
+        case AUDIO_GET_DEV_DRV_VER: {
+                unsigned int vers = DEV_DRV_VER;
+                if (copy_to_user((void *) arg, &vers, sizeof(vers)))
+                        rc = -EFAULT;
+                break;
 	}
-
-	mutex_lock(&audio->lock);
-	switch (cmd) {
 	case AUDIO_START: {
+
 		uint32_t freq;
+		struct timespec ts;	
 		/* Poll at 48KHz always */
 		freq = 48000;
 		MM_DBG("AUDIO_START\n");
-		rc = msm_snddev_request_freq(&freq, audio->enc_id,
-					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
-		MM_DBG("sample rate configured %d sample rate requested %d\n",
-				freq, audio->samp_rate);
+
+		if (audio->in_call && (audio->voice_state != VOICE_STATE_INCALL)) {
+			ts = CURRENT_TIME;
+			rc = wait_event_interruptible(audio->wait_voice_incall,
+				audio->voice_state == VOICE_STATE_INCALL || audio->stopped);
+			if(rc < 0 || audio->voice_state != VOICE_STATE_INCALL || audio->stopped) {
+				MM_DBG("valid incall state unreacheable\n");
+				return -EPERM;
+			}
+			ts = timespec_sub(CURRENT_TIME,ts);
+			MM_DBG("waited %ld.%03ld sec for voice incall state\n", ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+		}
+
+		rc = msm_snddev_request_freq(&freq, audio->enc_id, SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 		if (rc < 0) {
-			MM_DBG("sample rate can not be set, return code %d\n",\
-							rc);
+			MM_DBG("sample rate can not be set, return code %d\n",	rc);
 			msm_snddev_withdraw_freq(audio->enc_id,
 						SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 			MM_DBG("msm_snddev_withdraw_freq\n");
 			break;
 		}
+		MM_DBG("freq configured for %d\n", freq);
+
 		rc = audpcm_in_enable(audio);
-		if (!rc) {
-			rc =
-			wait_event_interruptible_timeout(audio->wait_enable,
-				audio->running != 0, 1*HZ);
-			MM_DBG("state %d rc = %d\n", audio->running, rc);
+		if (rc == 0) {
+			ts = CURRENT_TIME;
+			rc = wait_event_interruptible_timeout(audio->wait_enable, audio->running != 0, 3*HZ);
+			ts = timespec_sub(CURRENT_TIME,ts);
+			MM_DBG("state = %d, rc = %d after %ld.%03ld sec\n", audio->running, rc, 
+							ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+			rc = (audio->running == 0) ? -ENODEV : 0;
+		} else MM_DBG("failed to enable audpcm\n");
 
-			if (audio->running == 0)
-				rc = -ENODEV;
-			else
-				rc = 0;
+		if (rc == 0 && audio->in_call) {
+			rc = audpcm_in_record_config(audio, 1);
+			if (rc != 0) MM_ERR("failed to send record config cmd\n");
+			else  {
+				ts = CURRENT_TIME;
+				atomic_set(&audio->rec_conf,0);
+				wait_event_interruptible_timeout(audio->wait_rec_cfg,
+					atomic_read(&audio->rec_conf) != 0, 3*HZ);
+				if (atomic_read(&audio->rec_conf) == 0) {
+					MM_DBG("failed to config recording\n");
+					rc = -EFAULT;
+				} else {
+					ts = timespec_sub(CURRENT_TIME,ts);
+					MM_DBG("record config success after %ld.%03ld sec\n",
+							ts.tv_sec, ts.tv_nsec/NSEC_PER_MSEC);
+				}
+			}
 		}
 		audio->stopped = 0;
 		break;
 	}
 	case AUDIO_STOP: {
 		rc = audpcm_in_disable(audio);
-		rc = msm_snddev_withdraw_freq(audio->enc_id,
-					SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
-		MM_DBG("msm_snddev_withdraw_freq\n");
-		audio->stopped = 1;
-		audio->abort = 0;
+		if (rc != 0) MM_DBG("failed to stop audio\n");
+		rc = msm_snddev_withdraw_freq(audio->enc_id,SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 		break;
 	}
 	case AUDIO_FLUSH: {
+		MM_DBG("AUDIO_FLUSH\n");
 		if (audio->stopped) {
 			/* Make sure we're stopped and we wake any threads
 			 * that might be blocked holding the read_lock.
@@ -537,7 +632,11 @@
 			 * exit immediately.
 			 */
 			wake_up(&audio->wait);
-			mutex_lock(&audio->read_lock);
+			if (!mutex_trylock(&audio->read_lock)) 
+				do {
+					msleep(50);
+					wake_up(&audio->wait);
+				} while (!mutex_trylock(&audio->read_lock));
 			audpcm_in_flush(audio);
 			mutex_unlock(&audio->read_lock);
 		}
@@ -577,6 +676,34 @@
 			rc = -EFAULT;
 		break;
 	}
+        case AUDIO_SET_INCALL: {
+                struct msm_voicerec_mode cfg;
+                unsigned long flags;
+                MM_DBG("AUDIO_SET_INCALL\n");
+                if (copy_from_user(&cfg, (void *) arg, sizeof(cfg))) {
+                        rc = -EFAULT;
+                        break;
+                }
+                if (cfg.rec_mode != VOC_REC_BOTH &&
+                        cfg.rec_mode != VOC_REC_UPLINK &&
+                        cfg.rec_mode != VOC_REC_DOWNLINK) {
+                        MM_ERR("invalid rec_mode\n");
+                        rc = -EINVAL;
+                        break;
+                } else {
+                        spin_lock_irqsave(&audio->dev_lock, flags);
+                        if (cfg.rec_mode == VOC_REC_UPLINK)
+                                audio->source = VOICE_UL_SOURCE_MIX_MASK;
+                        else if (cfg.rec_mode == VOC_REC_DOWNLINK)
+                                audio->source = VOICE_DL_SOURCE_MIX_MASK;
+                        else
+                                audio->source = VOICE_DL_SOURCE_MIX_MASK |
+                                                VOICE_UL_SOURCE_MIX_MASK ;
+                        audio->in_call = 1;
+                        spin_unlock_irqrestore(&audio->dev_lock, flags);
+                }
+                break;
+        }
 	case AUDIO_GET_SESSION_ID: {
 		if (copy_to_user((void *) arg, &audio->enc_id,
 			sizeof(unsigned short))) {
@@ -587,10 +714,41 @@
 	default:
 		rc = -EINVAL;
 	}
+	if(rc != 0) MM_DBG("returning error %d\n",rc);
 	mutex_unlock(&audio->lock);
 	return rc;
 }
 
+static int reconfig_record(struct audio_in *audio) {
+
+	MM_DBG("\n");
+	mutex_lock(&audio->lock);
+	atomic_set(&audio->rec_conf,0);
+	if (audpcm_in_record_config(audio, 0) != 0) {
+		mutex_unlock(&audio->lock);
+		return -EFAULT;
+	}
+	wait_event_interruptible_timeout(audio->wait_rec_cfg, 
+			atomic_read(&audio->rec_conf) == 1, 1*HZ);
+	if (atomic_read(&audio->rec_conf) != 1) {
+		mutex_unlock(&audio->lock);
+		return -ENODEV;
+	}					
+	atomic_set(&audio->rec_conf,0);
+	if (audpcm_in_record_config(audio, 1) != 0) {
+		mutex_unlock(&audio->lock);
+		return -EFAULT;
+	}
+	wait_event_interruptible_timeout(audio->wait_rec_cfg, 
+			atomic_read(&audio->rec_conf) == 1, 1*HZ);
+	if (atomic_read(&audio->rec_conf) != 1) {
+		mutex_unlock(&audio->lock);
+		return -ENODEV;
+	}
+	mutex_unlock(&audio->lock);
+	return 0;
+}
+
 static ssize_t audpcm_in_read(struct file *file,
 				char __user *buf,
 				size_t count, loff_t *pos)
@@ -605,23 +763,35 @@
 
 	mutex_lock(&audio->read_lock);
 	while (count > 0) {
-		rc = wait_event_interruptible(
+
+                rc = wait_event_interruptible_timeout(
 			audio->wait, (audio->in_count > 0) || audio->stopped ||
-			audio->abort);
+                        (audio->in_call && audio->running &&
+                                (audio->voice_state == VOICE_STATE_OFFCALL)), 1*HZ);
 
-		if (rc < 0)
+		if (rc == 0 && !audio->in_count 
+			&& !audio->stopped && audio->voice_state == VOICE_STATE_INCALL) {
+			rc = reconfig_record(audio);
+			if (rc == 0) {
+				MM_DBG("Recording reconfigured\n");
+				continue;
+			}
+			MM_AUD_ERR("Failed to reconfigure recording\n");
 			break;
+		} else rc = 0;
 
-		if (audio->stopped && !audio->in_count) {
-			MM_DBG("Driver in stop state, No more buffer to read");
+                if (!audio->in_count) {
+                        if (audio->stopped) {
+                                MM_AUD_ERR("No more data, driver stopped\n");
 			rc = 0;/* End of File */
 			break;
-		}
-
-		if (audio->abort) {
-			rc = -EPERM; /* Not permitted due to abort */
+                        } else if (audio->in_call && audio->running &&
+                                (audio->voice_state == VOICE_STATE_OFFCALL)) {
+                                MM_AUD_ERR("No more data, already in off-call state\n");
+                                rc = -EPERM; /* Voice Call stopped */
 			break;
 		}
+		}
 
 		index = audio->in_tail;
 		data = (uint8_t *) audio->in[index].data;
@@ -633,19 +803,18 @@
 			}
 			spin_lock_irqsave(&audio->dsp_lock, flags);
 			if (index != audio->in_tail) {
-				/* overrun -- data is
-				 * invalid and we need to retry */
+				/* overrun -- data are invalid and we need to retry */
 				spin_unlock_irqrestore(&audio->dsp_lock, flags);
 				continue;
 			}
 			audio->in[index].size = 0;
 			audio->in_tail = (audio->in_tail + 1) & (FRAME_NUM - 1);
-			audio->in_count--;
+			if (audio->in_count) audio->in_count--;
 			spin_unlock_irqrestore(&audio->dsp_lock, flags);
 			count -= size;
 			buf += size;
 		} else {
-			MM_ERR("short read\n");
+			MM_AUD_ERR("short read\n");
 			break;
 		}
 	}
@@ -668,96 +837,129 @@
 {
 	struct audio_in *audio = file->private_data;
 
+	if (!audio) return 0;
 	mutex_lock(&audio->lock);
-	/* with draw frequency for session
-	   incase not stopped the driver */
-	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX,
-					AUDDEV_CLNT_ENC);
+	audio->in_call = 0;
+
+	msm_snddev_withdraw_freq(audio->enc_id, SNDDEV_CAP_TX, AUDDEV_CLNT_ENC);
 	auddev_unregister_evt_listner(AUDDEV_CLNT_ENC, audio->enc_id);
 	audpcm_in_disable(audio);
 	audpcm_in_flush(audio);
-	msm_adsp_put(audio->audrec);
-	audpreproc_aenc_free(audio->enc_id);
-	audio->audrec = NULL;
-	audio->opened = 0;
+	if (audio->audrec) msm_adsp_put(audio->audrec);
+	if (audio->enc_id >=0) audpreproc_aenc_free(audio->enc_id);
+
+	iounmap(audio->data);
+	pmem_kfree(audio->phys);
+
 	mutex_unlock(&audio->lock);
+
+	kfree(audio);
+
+#ifdef TEST_ONLY
+	current_audio_in = 0;
+#endif
+
+	MM_DBG("closed.\n");
+
 	return 0;
 }
 
 static int audpcm_in_open(struct inode *inode, struct file *file)
 {
-	struct audio_in *audio = &the_audio_in;
+	struct audio_in *audio;
+	const char *modname;	
 	int rc;
-	int encid;
 
-	mutex_lock(&audio->lock);
-	if (audio->opened) {
-		rc = -EBUSY;
-		goto done;
+
+	audio = kzalloc(sizeof(struct audio_in), GFP_KERNEL);
+
+	if (!audio) return -ENOMEM;
+
+#ifdef TEST_ONLY
+	current_audio_in = audio;
+#endif
+
+        audio->phys = pmem_kalloc(DMASZ, PMEM_MEMTYPE_EBI1 | PMEM_ALIGNMENT_4K);
+        if (!IS_ERR((void *) audio->phys)) {
+		audio->data = ioremap(audio->phys, DMASZ);
+                if (!audio->data) {
+       	                MM_AUD_ERR("Could not remap DMA buffers\n");
+               	        pmem_kfree(audio->phys);
+			kfree(audio);
+                       	return -ENOMEM;
 	}
-	if ((file->f_mode & FMODE_WRITE) &&
-			(file->f_mode & FMODE_READ)) {
-		rc = -EACCES;
-		MM_ERR("Non tunnel encoding is not supported\n");
-		goto done;
-	} else if (!(file->f_mode & FMODE_WRITE) &&
-					(file->f_mode & FMODE_READ)) {
-		audio->mode = MSM_AUD_ENC_MODE_TUNNEL;
-		MM_DBG("Opened for tunnel mode encoding\n");
 	} else {
-		rc = -EACCES;
-		goto done;
+       	        MM_AUD_ERR("Could not allocate DMA buffers\n");
+		kfree(audio);
+               	return -ENOMEM;
 	}
-	/* Settings will be re-config at AUDIO_SET_CONFIG,
-	 * but at least we need to have initial config
-	 */
-	audio->channel_mode = AUDREC_CMD_MODE_MONO;
-	audio->buffer_size = MONO_DATA_SIZE;
-	audio->samp_rate = 8000;
-	audio->enc_type = ENC_TYPE_WAV | audio->mode;
-	audio->source = INTERNAL_CODEC_TX_SOURCE_MIX_MASK;
 
-	encid = audpreproc_aenc_alloc(audio->enc_type, &audio->module_name,
-			&audio->queue_ids);
-	if (encid < 0) {
-		MM_ERR("No free encoder available\n");
+	audio->enc_id = audpreproc_aenc_alloc(ENC_TYPE_WAV | MSM_AUD_ENC_MODE_TUNNEL, 
+					&modname, &audio->queue_ids);
+	if (audio->enc_id < 0) {
+		MM_AUD_ERR("No free encoder available\n");
 		rc = -ENODEV;
-		goto done;
+		goto no_aenc;
 	}
-	audio->enc_id = encid;
 
-	rc = msm_adsp_get(audio->module_name, &audio->audrec,
-			   &audrec_adsp_ops, audio);
+	MM_DBG("allocated encoder %d, module %s\n", audio->enc_id, modname);
 
+	rc = auddev_register_evt_listner(AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
+					AUDDEV_EVT_FREQ_CHG | AUDDEV_EVT_VOICE_STATE_CHG,
+					AUDDEV_CLNT_ENC, audio->enc_id,
+					audpcm_in_listener, audio);
 	if (rc) {
-		audpreproc_aenc_free(audio->enc_id);
-		goto done;
+		MM_AUD_ERR("failed to register device event listener\n");
+		goto evt_error;
 	}
 
-	audio->stopped = 0;
-	audio->source = 0;
-	audio->abort = 0;
-	audpcm_in_flush(audio);
-	audio->device_events = AUDDEV_EVT_DEV_RDY | AUDDEV_EVT_DEV_RLS |
-				AUDDEV_EVT_FREQ_CHG;
+	rc = msm_adsp_get(modname, &audio->audrec, &audrec_adsp_ops, audio);
 
-	rc = auddev_register_evt_listner(audio->device_events,
-					AUDDEV_CLNT_ENC, audio->enc_id,
-					pcm_in_listener, (void *) audio);
 	if (rc) {
-		MM_ERR("failed to register device event listener\n");
-		goto evt_error;
+		MM_AUD_ERR("Failed to get AUDREC task\n");
+		goto no_audrec;
+	}
+
+	if(!audio->audrec) {
+		MM_AUD_ERR("Null AUDREC task returned by ADSP\n");
+		rc = -EFAULT;
+		goto no_audrec;
 	}
+
+	audio->source  = INTERNAL_CODEC_TX_SOURCE_MIX_MASK;
+	audio->channel_mode = AUDREC_CMD_MODE_MONO;
+	audio->buffer_size = MONO_DATA_SIZE;
+	audio->samp_rate = 8000;
+	audio->stopped = 0;
+	audio->running = 0;
+	audio->enabled = 0;
+	audpcm_in_flush(audio);
+
+	mutex_init(&audio->lock);
+	mutex_init(&audio->read_lock);
+	spin_lock_init(&audio->dsp_lock);
+	spin_lock_init(&audio->dev_lock);
+	init_waitqueue_head(&audio->wait);
+	init_waitqueue_head(&audio->wait_enable);
+	init_waitqueue_head(&audio->wait_voice_incall);
+	init_waitqueue_head(&audio->wait_rec_cfg);
+
+        audio->voice_state = msm_get_voice_state();
+
 	file->private_data = audio;
-	audio->opened = 1;
-	rc = 0;
-done:
-	mutex_unlock(&audio->lock);
+
 	return rc;
+
+no_audrec:
+	auddev_unregister_evt_listner(AUDDEV_CLNT_ENC, audio->enc_id);
 evt_error:
-	msm_adsp_put(audio->audrec);
 	audpreproc_aenc_free(audio->enc_id);
-	mutex_unlock(&audio->lock);
+
+no_aenc:
+        iounmap(audio->data);
+	pmem_kfree(audio->phys);
+	kfree(audio);	
+
 	return rc;
 }
 
@@ -778,22 +980,9 @@
 
 static int __init audpcm_in_init(void)
 {
-	the_audio_in.data = dma_alloc_coherent(NULL, DMASZ,
-					       &the_audio_in.phys, GFP_KERNEL);
-	MM_DBG("Memory addr = 0x%8x  phy addr = 0x%8x ---- \n", \
-		(int) the_audio_in.data, (int) the_audio_in.phys);
-
-	if (!the_audio_in.data) {
-		MM_ERR("Unable to allocate DMA buffer\n");
-		return -ENOMEM;
-	}
-	mutex_init(&the_audio_in.lock);
-	mutex_init(&the_audio_in.read_lock);
-	spin_lock_init(&the_audio_in.dsp_lock);
-	spin_lock_init(&the_audio_in.dev_lock);
-	init_waitqueue_head(&the_audio_in.wait);
-	init_waitqueue_head(&the_audio_in.wait_enable);
 	return misc_register(&audio_in_misc);
 }
 
 device_initcall(audpcm_in_init);
+
+
